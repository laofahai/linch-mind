name: ðŸ”§ Daemon Service Build & Deploy

on:
  push:
    branches: [main, develop]
    paths:
      - 'daemon/**'
      - '.github/workflows/daemon-build.yml'
    tags:
      - 'daemon-v*'
      - 'v*'
  pull_request:
    branches: [main]
    paths:
      - 'daemon/**'
  workflow_dispatch:
    inputs:
      deploy_target:
        description: 'Deployment target'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - production
          - none
      python_version:
        description: 'Python version to test'
        required: false
        default: '3.11'
        type: string

env:
  PYTHON_VERSION: "3.11"
  POETRY_VERSION: "1.7.1"
  REGISTRY: ghcr.io
  IMAGE_NAME: linch-mind/daemon

jobs:
  # å˜æ›´æ£€æµ‹å’Œç‰ˆæœ¬ç®¡ç†
  detect-changes:
    name: ðŸ” Detect Changes & Version
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.changes.outputs.should_build }}
      version: ${{ steps.version.outputs.version }}
      is_release: ${{ steps.version.outputs.is_release }}
      deploy_target: ${{ steps.deploy.outputs.target }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Check for daemon changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" = "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "should_build=true" >> $GITHUB_OUTPUT
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep '^daemon/' || true)
            if [ -n "$CHANGED_FILES" ]; then
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "Daemon changes detected:"
              echo "$CHANGED_FILES"
            else
              echo "should_build=false" >> $GITHUB_OUTPUT
              echo "No daemon changes detected"
            fi
          fi
      
      - name: Extract version and release info
        id: version
        run: |
          cd daemon
          
          # ä»Žpyproject.tomlæå–ç‰ˆæœ¬
          VERSION=$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
          
          # æ£€æŸ¥æ˜¯å¦ä¸ºå‘å¸ƒç‰ˆæœ¬
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            echo "is_release=true" >> $GITHUB_OUTPUT
            TAG_VERSION="${{ github.ref_name }}"
            
            # éªŒè¯tagå’Œç‰ˆæœ¬ä¸€è‡´æ€§
            if [[ "$TAG_VERSION" == "daemon-v$VERSION" ]] || [[ "$TAG_VERSION" == "v$VERSION" ]]; then
              echo "âœ… Version tag matches pyproject.toml"
            else
              echo "âŒ Version mismatch: tag $TAG_VERSION vs pyproject.toml v$VERSION"
              exit 1
            fi
          else
            echo "is_release=false" >> $GITHUB_OUTPUT
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Daemon version: $VERSION"
      
      - name: Determine deployment target
        id: deploy
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TARGET="${{ github.event.inputs.deploy_target }}"
          elif [ "${{ steps.version.outputs.is_release }}" = "true" ]; then
            TARGET="production"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            TARGET="staging"
          else
            TARGET="none"
          fi
          
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "Deployment target: $TARGET"

  # Pythonä»£ç è´¨é‡æ£€æŸ¥
  quality-check:
    name: ðŸ” Code Quality & Security
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_build == 'true'
    
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true
      
      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v3
        with:
          path: daemon/.venv
          key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('daemon/poetry.lock') }}
      
      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: |
          cd daemon
          poetry install --no-interaction --no-root
      
      - name: Install project
        run: |
          cd daemon
          poetry install --no-interaction
      
      - name: Lint with flake8
        run: |
          cd daemon
          poetry run flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
          poetry run flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
      
      - name: Type checking with mypy
        run: |
          cd daemon
          poetry run mypy . --ignore-missing-imports || true
      
      - name: Security audit with bandit
        run: |
          cd daemon
          poetry run bandit -r . -f json -o bandit-report.json || true
          poetry run bandit -r . || true
      
      - name: Dependency vulnerability check
        run: |
          cd daemon
          poetry run safety check || true
      
      - name: Upload security reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-reports-py${{ matrix.python-version }}
          path: daemon/bandit-report.json
          retention-days: 30

  # å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
  test:
    name: ðŸ§ª Test Suite
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_build == 'true'
    
    services:
      # å¦‚æžœéœ€è¦æ•°æ®åº“æœåŠ¡ï¼Œå¯ä»¥åœ¨è¿™é‡Œæ·»åŠ 
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: linch_mind_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true
      
      - name: Load cached venv
        id: cached-poetry-dependencies
        uses: actions/cache@v3
        with:
          path: daemon/.venv
          key: venv-${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('daemon/poetry.lock') }}
      
      - name: Install dependencies
        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'
        run: |
          cd daemon
          poetry install --no-interaction --no-root --with dev
      
      - name: Install project
        run: |
          cd daemon
          poetry install --no-interaction
      
      - name: Create test database
        run: |
          cd daemon
          # å¦‚æžœä½¿ç”¨SQLiteï¼Œç¡®ä¿æµ‹è¯•æ•°æ®åº“ç›®å½•å­˜åœ¨
          mkdir -p tests/data
      
      - name: Run unit tests
        run: |
          cd daemon
          poetry run pytest tests/ -v --cov=. --cov-report=xml --cov-report=html --cov-report=term
        env:
          # æµ‹è¯•çŽ¯å¢ƒå˜é‡
          LINCH_MIND_ENV: test
          DATABASE_URL: sqlite:///tests/data/test.db
          # å¦‚æžœä½¿ç”¨PostgreSQL
          # DATABASE_URL: postgresql://postgres:test@localhost:5432/linch_mind_test
      
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          file: daemon/coverage.xml
          flags: daemon
          name: daemon-coverage
      
      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            daemon/coverage.xml
            daemon/htmlcov/
            daemon/pytest.xml
          retention-days: 30

  # APIæ–‡æ¡£ç”Ÿæˆå’ŒéªŒè¯
  api-docs:
    name: ðŸ“š API Documentation
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should_build == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          version: ${{ env.POETRY_VERSION }}
          virtualenvs-create: true
          virtualenvs-in-project: true
      
      - name: Install dependencies
        run: |
          cd daemon
          poetry install --no-interaction
      
      - name: Generate OpenAPI schema
        run: |
          cd daemon
          poetry run python -c "
          from api.main import app
          import json
          
          schema = app.openapi()
          with open('openapi.json', 'w') as f:
              json.dump(schema, f, indent=2)
          print('âœ… OpenAPI schema generated')
          "
      
      - name: Validate API schema
        run: |
          cd daemon
          # éªŒè¯OpenAPI schemaçš„æœ‰æ•ˆæ€§
          poetry run python -c "
          import json
          with open('openapi.json', 'r') as f:
              schema = json.load(f)
          
          # åŸºæœ¬éªŒè¯
          assert 'openapi' in schema
          assert 'info' in schema
          assert 'paths' in schema
          print('âœ… API schema is valid')
          "
      
      - name: Upload API documentation
        uses: actions/upload-artifact@v4
        with:
          name: api-docs
          path: daemon/openapi.json
          retention-days: 30

  # Dockeré•œåƒæž„å»º
  build-docker:
    name: ðŸ³ Build Docker Image
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-check, test]
    if: needs.detect-changes.outputs.should_build == 'true'
    
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ needs.detect-changes.outputs.version }}
            type=sha,prefix={{branch}}-
      
      - name: Create Dockerfile if not exists
        run: |
          if [ ! -f daemon/Dockerfile ]; then
            cat > daemon/Dockerfile << 'EOF'
          FROM python:3.11-slim as builder
          
          # Install Poetry
          RUN pip install poetry==1.7.1
          
          # Configure Poetry
          ENV POETRY_NO_INTERACTION=1 \
              POETRY_VENV_IN_PROJECT=1 \
              POETRY_CACHE_DIR=/tmp/poetry_cache
          
          WORKDIR /app
          
          # Copy dependency files
          COPY pyproject.toml poetry.lock ./
          
          # Install dependencies
          RUN poetry install --only=main && rm -rf $POETRY_CACHE_DIR
          
          # Production stage
          FROM python:3.11-slim as runtime
          
          # Install system dependencies
          RUN apt-get update && apt-get install -y \
              curl \
              && rm -rf /var/lib/apt/lists/*
          
          # Create non-root user
          RUN groupadd -r linch && useradd -r -g linch linch
          
          WORKDIR /app
          
          # Copy virtual environment from builder stage
          COPY --from=builder /app/.venv /app/.venv
          
          # Make sure scripts in .venv are usable
          ENV PATH="/app/.venv/bin:$PATH"
          
          # Copy application code
          COPY . .
          
          # Change ownership to non-root user
          RUN chown -R linch:linch /app
          USER linch
          
          # Expose port
          EXPOSE 8000
          
          # Health check
          HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:8000/health || exit 1
          
          # Run the application
          CMD ["python", "-m", "uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "8000"]
          EOF
            echo "âœ… Generated Dockerfile"
          else
            echo "âœ… Using existing Dockerfile"
          fi
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./daemon
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64
      
      - name: Run container security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.detect-changes.outputs.version }}
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # éƒ¨ç½²åˆ°stagingçŽ¯å¢ƒ
  deploy-staging:
    name: ðŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [detect-changes, build-docker]
    if: needs.detect-changes.outputs.deploy_target == 'staging'
    environment:
      name: staging
      url: https://staging.linch-mind.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to staging
        run: |
          echo "ðŸš€ Deploying daemon v${{ needs.detect-changes.outputs.version }} to staging..."
          
          # è¿™é‡Œå¯ä»¥æ·»åŠ å®žé™…çš„éƒ¨ç½²é€»è¾‘ï¼Œæ¯”å¦‚ï¼š
          # - æ›´æ–°Docker Composeé…ç½®
          # - éƒ¨ç½²åˆ°Kubernetesé›†ç¾¤
          # - è°ƒç”¨éƒ¨ç½²API
          # - æ›´æ–°äº‘æœåŠ¡é…ç½®
          
          echo "Docker image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.detect-changes.outputs.version }}"
          echo "âœ… Staging deployment simulated"
      
      - name: Run smoke tests
        run: |
          echo "ðŸ§ª Running smoke tests against staging..."
          
          # ç­‰å¾…æœåŠ¡å¯åŠ¨
          sleep 30
          
          # å¥åº·æ£€æŸ¥
          # curl -f https://staging.linch-mind.com/health || exit 1
          
          # APIåŠŸèƒ½æµ‹è¯•
          # curl -f https://staging.linch-mind.com/api/v1/health || exit 1
          
          echo "âœ… Smoke tests passed"
      
      - name: Notify deployment
        run: |
          echo "ðŸ“¢ Staging deployment notification"
          echo "Version: ${{ needs.detect-changes.outputs.version }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.detect-changes.outputs.version }}"

  # éƒ¨ç½²åˆ°ç”Ÿäº§çŽ¯å¢ƒ
  deploy-production:
    name: ðŸŒŸ Deploy to Production
    runs-on: ubuntu-latest
    needs: [detect-changes, build-docker, deploy-staging]
    if: needs.detect-changes.outputs.deploy_target == 'production' && needs.detect-changes.outputs.is_release == 'true'
    environment:
      name: production
      url: https://api.linch-mind.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to production
        run: |
          echo "ðŸŒŸ Deploying daemon v${{ needs.detect-changes.outputs.version }} to production..."
          
          # ç”Ÿäº§éƒ¨ç½²é€»è¾‘
          echo "Docker image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.detect-changes.outputs.version }}"
          echo "âœ… Production deployment simulated"
      
      - name: Run production health checks
        run: |
          echo "ðŸ¥ Running production health checks..."
          
          # ç­‰å¾…æœåŠ¡å¯åŠ¨
          sleep 60
          
          # è¯¦ç»†çš„ç”Ÿäº§å¥åº·æ£€æŸ¥
          echo "âœ… Production health checks passed"
      
      - name: Create deployment record
        run: |
          echo "ðŸ“ Creating deployment record..."
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Version: ${{ needs.detect-changes.outputs.version }}"
          echo "Environment: production"
          echo "Status: success"

  # æž„å»ºçŠ¶æ€æ±‡æ€»
  build-summary:
    name: ðŸ“Š Build Summary
    runs-on: ubuntu-latest
    needs: [detect-changes, quality-check, test, api-docs, build-docker]
    if: always() && needs.detect-changes.outputs.should_build == 'true'
    
    steps:
      - name: Generate build summary
        run: |
          echo "## ðŸ”§ Daemon Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: ${{ needs.detect-changes.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Is Release**: ${{ needs.detect-changes.outputs.is_release }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deploy Target**: ${{ needs.detect-changes.outputs.deploy_target }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ“‹ Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- **Quality Check**: ${{ needs.quality-check.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests**: ${{ needs.test.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **API Docs**: ${{ needs.api-docs.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Build**: ${{ needs.build-docker.result == 'success' && 'âœ…' || 'âŒ' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### ðŸ³ Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "\`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.detect-changes.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # æ•´ä½“çŠ¶æ€
          if [ "${{ needs.quality-check.result }}" = "success" ] && 
             [ "${{ needs.test.result }}" = "success" ] && 
             [ "${{ needs.build-docker.result }}" = "success" ]; then
            echo "ðŸŽ‰ **Overall Status**: SUCCESS" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Overall Status**: FAILED" >> $GITHUB_STEP_SUMMARY
          fi